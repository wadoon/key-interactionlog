package org.key_project.ui.interactionlog.algo

import org.key_project.ui.interactionlog.Markdown
import org.key_project.ui.interactionlog.api.Interaction
import org.key_project.ui.interactionlog.api.Markdownable
import org.key_project.ui.interactionlog.model.InteractionLog
import java.io.PrintWriter
import java.util.*

/**
 * Information about how to read an interaction log in markdown.
 * This is a string, that gets injected into the generated markdown.
 */
private val HOWTO: String = """

## How to read this document

    
""".trimIndent()

class MarkdownExport(val logbook: InteractionLog, val writer: PrintWriter) {

    fun run() {
        writer.format(
            """"
# ${logbook.name}

Interaction of the ${logbook.created}

This markdown file was generated by the interaction log extension.
It was created on the ${Date()} by user ${System.getenv("user.name")}.

""".trimIndent()
        )

        logbook.proof.use {
            writer.format("Following information were present about the proof:\n")
            writer.format("* Name of the proof: ${it.name()}\n")
            writer.format("* Abbreviations:")
            it.abbreviations().export().forEach { p ->
                writer.format("  * `${p.second}` := `${p.first}`\n")
            }
            writer.format("* Proof file: ${it.proofFile}\n")
            writer.format("* Number of open goals: ${it.openGoals().size()}\n")
            writer.format("* Definition header \n```\n${it.header()}\n```\n")
            writer.format(
                """
            * Statistics: \n" +
              * autoModeTimeInMillis: ${it.statistics.autoModeTimeInMillis}    
              * blockLoopContractApps: ${it.statistics.blockLoopContractApps}    
              * branches: ${it.statistics.branches}    
              * dependencyContractApps: ${it.statistics.dependencyContractApps}    
              * interactiveSteps: ${it.statistics.interactiveSteps}    
              * loopInvApps: ${it.statistics.loopInvApps}    
              * mergeRuleApps: ${it.statistics.mergeRuleApps}    
              * nodes: ${it.statistics.nodes}    
              * operationContractApps: ${it.statistics.operationContractApps}    
              * ossApps: ${it.statistics.ossApps}    
              * smtSolverApps: ${it.statistics.smtSolverApps}    
              * quantifierInstantiations: ${it.statistics.quantifierInstantiations}    
              * symbExApps:  ${it.statistics.symbExApps}    
              * timeInMillis:  ${it.statistics.timeInMillis}    
              * timePerStepInMillis: ${it.statistics.timePerStepInMillis}    
              * autoModeTimeInMillis: ${it.statistics.autoModeTimeInMillis}    
              * totalRuleApps: ${it.statistics.totalRuleApps}    
                """.trimIndent()
            )
        }

        writer.append("\n\n$HOWTO\n\n")

        logbook.interactions.forEach { writer.format(it.toMarkdown() + "\n\n") }
    }

}

fun Interaction?.toMarkdown() = try {
    val m = this as Markdownable
    m.markdown
} catch (e: ClassCastException) {
    "No markdown available for $this"
}

fun Interaction?.toHtml() = Markdown.html(toMarkdown())
